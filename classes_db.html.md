# Define Classes and create the SQLite database


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

We use `from __future__ import annotations` to support forward
references in type hints. To be precise in the `@classmethod` we create
to keep track of all instances of the class.

## Using Pydantic with MiniDataAPI and SQLite

We want to use `Pydantic` Dataclasses to enable typechecking and
validation. We also want to use the Dataclasses with the `MiniDataAPI`
to create the tables in the `SQLite` database. But `SQLite` only has
datatypes: `NULL`, `INTEGER`, `REAL`, `TEXT`, and `BLOB`. So no `list`
or any of the Dataclass(Enum) types we use.

To be able to use both `Pydanctic` and the `MiniDataAPI` we will do two
things:

1.  Define a Pydantic Dataclass with the correct datatypes and a
    Dataclass that has the same fields as the Pydantic Dataclass, but
    with datatypes that can be used with SQLite.
2.  We add `@field_serializer` methods to the Pydantic Dataclass that
    convert the fields to JSON strings when we use the method
    `.model_dump()` on the instance of the Pydantic Dataclass. These
    serialised JSON strings can then be added to the SQLite database.
3.  We also use the `@field_validator` decorator to convert the JSON
    strings back to the correct datatypes when we load the data from the
    SQLite database back into the Pydantic Dataclass.

This way we can:

- create instances with the Pydantic Dataclass to have easy typechecking
  and validation.
- convert this instances to `MiniDataAPI` and `SQLite` friendly
  datatypes using `.model_dump()` on the instance, that we can then add
  to the database.
- load the data from the SQLite database back into the Pydantic
  Dataclass.

The exact implementation can be found below where the Classes are
defined.

#### Track instances of classes

We also want to keep track of the instances available for each class.
Therefore we need some higher order magic.

- a list in the class to store the instances
- a **init** method to add the instance to the list
- a classmethod to get the list of instances

We can’t just add a `_instances = []` statement to the Class, because
Pydantic will then assume it is a model field (private attribute). We
need to tell Pydantic to ignore the \_instances class variable as a
model field and treat is as a class variable. Therefore we need to
import `ClassVar` from `typing` and use it to type the \_instances
variable.

## Enum Classes

First we define the possible values of the different variables that are
available in the classes. We use the module `enum` to define
**Enumerations**. We use this to bind the possible values to a variable
name, making the code more readable and maintainable.

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L58"
target="_blank" style="float:right; font-size:smaller">source</a>

### OrganizationSystem

>  OrganizationSystem (value, names=None, module=None, qualname=None,
>                          type=None, start=1, boundary=None)

*How tools organize and structure information.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L51"
target="_blank" style="float:right; font-size:smaller">source</a>

### PhaseQuality

>  PhaseQuality (value, names=None, module=None, qualname=None, type=None,
>                    start=1, boundary=None)

*Quality rating for how well a tool performs in each phase.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L43"
target="_blank" style="float:right; font-size:smaller">source</a>

### Phase

>  Phase (value, names=None, module=None, qualname=None, type=None, start=1,
>             boundary=None)

*The five phases of the PKM workflow.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L37"
target="_blank" style="float:right; font-size:smaller">source</a>

### Method

>  Method (value, names=None, module=None, qualname=None, type=None,
>              start=1, boundary=None)

*How actions are performed - manually or automatically.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L22"
target="_blank" style="float:right; font-size:smaller">source</a>

### InformationType

>  InformationType (value, names=None, module=None, qualname=None,
>                       type=None, start=1, boundary=None)

*Information content types that flow through the PKM workflow.*

``` python
Phase("refine")
```

    <Phase.REFINE: 'refine'>

## Base class to use for database classes

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L66"
target="_blank" style="float:right; font-size:smaller">source</a>

### SluggedModel

>  SluggedModel ()

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

## PKM Workflow Classes

Next we create a dataclass for each item we need to be present in the
PKM workflow.

**Pydantic Dataclasses**

Used for typechecking.

When creating a new instance for an
[`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)
the `toolflow` must be given as a list of
[`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)
objects. The typechecking makes sure that any
[`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)
object mentioned in the `toolfow` list, does exist as an actual
[`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)
instance. So make sure to first create all the
[`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)
instances that are needed for an
[`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem),
before creating the
[`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)
instance.

<div>

> **Tip**
>
> I had some serious trouble getting the Pydantic dataclass validations
> to work. One of the issues is described above and is about SQLite not
> supporting all datatypes. A second major issue is that the Pydantic
> Dataclasses reference each other. The
> [`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)
> references the
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool) in
> the `toolflow` field. I would also be convenient to store all the
> [`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)s
> that can be used with a certain
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool),
> but in that case we would create a circular reference between
> [`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)
> and
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool).
>
> We decided to remove the `information_items` list from
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool).
> When we need to get all the
> [`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)s
> that are supported by a
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool) we
> can write a Python function or do a SQL-query on the SQLite database.
>
> But then we are left with the fact that we want a list of
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)s
> that exist. These are the options considered:
>
> - `toolflow: list[Tool]`
> - `toolflow: list[Tool.name]`
> - `toolflow: list[str]`
>
> The last option is used in combination with validation to ensure each
> string is a valid Tool.name.
>
> Here’s why this is the best approach:
>
> - Clean serialization (no complex object embedding)
> - Human-readable in the database
> - Type safety through validation
> - Easy to query
>
> The same goes for the
> [`Improvement`](https://Hopsakee.github.io/infoflow/classes_db.html#improvement)
> class and the field `tool`.

</div>

## Explainer for the Pydantic Dataclass [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)

### Method [`Tool.from_db`](https://Hopsakee.github.io/infoflow/classes_db.html#tool.from_db)

``` python
@classmethod
def from_db(cls, db_record):
    phase_quality = PhaseQualityData(
        collect=PhaseQuality(db_record['collect_quality']),
        retrieve=PhaseQuality(db_record['retrieve_quality']),
        consume=PhaseQuality(db_record['consume_quality']),
        extract=PhaseQuality(db_record['extract_quality']),
        refine=PhaseQuality(db_record['refine_quality'])
    )
    org_systems = [OrganizationSystem(s) for s in json.loads(db_record['organization_system'])]
    return cls(
        id=db_record['id'],
        name=db_record['name'],
        description=db_record.get('description'),
        organization_system=org_systems,
        phase_quality=phase_quality,
        collect=db_record['collect'],
        retrieve=db_record['retrieve'],
        consume=db_record['consume'],
        extract=db_record['extract'],
        refine=db_record['refine']
    )
```

- **Input**: `db_record` is a row from the
  [Tools](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:110:8-126:31)
  table (e.g. a dict-like object from fastlite).
- **Rebuild `phase_quality`**:
  - DB stores each quality as a string
    (`'na' | 'bad' | 'ok' | 'great'`).
  - [PhaseQualityData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:65:0-70:49)
    is reconstructed by wrapping each DB value with the
    [PhaseQuality](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:50:0-55:19)
    enum.
- **Rebuild `organization_system`**:
  - DB stores it as a JSON string representing a list of enum values,
    e.g. `["tags","folders"]`.
  - `json.loads` turns that into a Python list of strings.
  - Each string is turned into an
    [OrganizationSystem](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:57:0-62:37)
    enum instance.
- **Instantiate
  [Tool](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:72:0-133:316)**:
  - Pass all the primitive fields straight from `db_record`.
  - Pass the reconstructed `phase_quality` and `organization_system`.
- **Side-effect**:
  - [**init**](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:99:4-101:47)
    registers the instance in `Tool._instances` keyed by
    [slug](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:87:4-90:45).

**In short**:
[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)
converts DB‑friendly fields (JSON/string) back into enum-rich,
structured Pydantic objects.

------------------------------------------------------------------------

## 2. [InformationItem.from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:225:4-235:117)

``` python
@classmethod
def from_db(cls, db_record):
    toolflow = PhaseToolflowData(
        collect=cls._parse_toolflow(db_record['collect_toolflow']),
        retrieve=cls._parse_toolflow(db_record['retrieve_toolflow']),
        consume=cls._parse_toolflow(db_record['consume_toolflow']),
        extract=cls._parse_toolflow(db_record['extract_toolflow']),
        refine=cls._parse_toolflow(db_record['refine_toolflow'])
    )
    method = PhaseMethodData(
        collect=db_record['collect_method'],
        retrieve=db_record['retrieve_method'],
        consume=db_record['consume_method'],
        extract=db_record['extract_method'],
        refine=db_record['refine_method']
    )
    info_type = InformationType(db_record['info_type'])
    return cls(
        id=db_record['id'],
        name=db_record['name'],
        info_type=info_type,
        method=method,
        toolflow=toolflow
    )
```

The helper:

``` python
@staticmethod
def _parse_toolflow(v):
    if v is None: return None
    if isinstance(v, str) and v.startswith('['): return json.loads(v)
    return v
```

- **Input**: a row from
  [InformationItems](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:196:8-211:32).
- **Rebuild `toolflow`**:
  - DB stores each `*_toolflow` as either:
    - `NULL`/`None`,
    - a plain string (single tool),
    - or a JSON-encoded list (multiple tools).
  - [\_parse_toolflow](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:218:4-223:16):
    - returns `None` for `None`,
    - `json.loads` if it looks like a JSON list (starts with `'['`),
    - otherwise leaves the string as‑is.
  - Those values feed into
    [PhaseToolflowData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:144:0-159:40)
    (which itself sanitizes names via validators).
- **Rebuild `method`**:
  - Note: DB stores method values as strings (`"manual"`, `"automatic"`,
    `"na"` or `None`).
  - [PhaseMethodData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:136:0-141:47)
    fields are annotated as `Method | None`, so Pydantic will convert
    those strings to
    [Method](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:36:0-40:27)
    enums automatically.
- **Rebuild `info_type`**:
  - DB stores `info_type` as its string value (e.g. `"book"`).
  - This is wrapped into
    [InformationType](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:21:0-34:33).
- **Instantiate
  [InformationItem](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:163:0-235:117)**:
  - Pass the reconstructed `info_type`, `method`, `toolflow`, plus `id`
    and `name`.
  - [**init**](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:99:4-101:47)
    adds the instance to `InformationItem._instances`.

**In short**:
[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)
reverses the flattening that turned nested structures
([PhaseMethodData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:136:0-141:47),
[PhaseToolflowData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:144:0-159:40),
[InformationType](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:21:0-34:33))
into many DB columns + JSON strings.

------------------------------------------------------------------------

## 3. [Improvement.from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:295:4-298:171)

``` python
@classmethod
def from_db(cls, db_record):
    phase = Phase(db_record['phase'])
    return cls(
        id=db_record['id'],
        title=db_record['title'],
        what=db_record['what'],
        why=db_record['why'],
        prio=db_record['prio'],
        tool=db_record['tool'],
        phase=phase
    )
```

- **Input**: a row from
  [Improvements](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:272:8-282:21).
- **Rebuild `phase`**:
  - DB stores `phase` as a string (e.g. `"collect"`).
  - Wrap in the
    [Phase](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:42:0-48:21)
    enum.
- **Instantiate
  [Improvement](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:238:0-298:171)**:
  - All other fields are passed through as-is.
  - [**init**](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:99:4-101:47)
    registers in `Improvement._instances`.
  - `tool` will be validated against
    [Tool.get_instances()](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:103:4-105:29)
    by the `field_validator`, so this will raise if the referenced tool
    slug is unknown.

**In short**:
[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)
here is simpler: it only converts the stored phase string to a
[Phase](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:42:0-48:21)
enum and lets Pydantic + validators do the rest.

------------------------------------------------------------------------

## Conceptual pattern across all three

- **DB schema is “flattened”**:
  - Enums → strings.
  - Lists/tuples → JSON text.
  - Nested models → multiple columns.
- **[flatten_for_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:92:4-95:19)**
  does the forward conversion to DB‑friendly fields.
- **[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)**
  does the reverse: rehydrate Enums, nested Pydantic models, and
  collections from that DB representation, returning fully-typed domain
  models ready for use in the app.

If you want, I can also trace one concrete row (e.g. a
[Tool](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:72:0-133:316)
with multiple `organization_system` values) through
[flatten_for_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:92:4-95:19)
→ SQLite row →
[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)
for a more step-by-step example.I’ll open `infoflow/classdb.py`, find
the
[`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem),
[`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool), and
[`Improvement`](https://Hopsakee.github.io/infoflow/classes_db.html#improvement)
Pydantic dataclasses, and then walk through how their `from_db` methods
behave, including any differences between them.

Here’s how
[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)
works for each of the three Pydantic models, based on
[classdb.py](cci:7://file:///home/jelle/code/infoflow/infoflow/classdb.py:0:0-0:0).

------------------------------------------------------------------------

## 1. [Tool.from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)

``` python
@classmethod
def from_db(cls, db_record):
    phase_quality = PhaseQualityData(
        collect=PhaseQuality(db_record['collect_quality']),
        retrieve=PhaseQuality(db_record['retrieve_quality']),
        consume=PhaseQuality(db_record['consume_quality']),
        extract=PhaseQuality(db_record['extract_quality']),
        refine=PhaseQuality(db_record['refine_quality'])
    )
    org_systems = [OrganizationSystem(s) for s in json.loads(db_record['organization_system'])]
    return cls(
        id=db_record['id'],
        name=db_record['name'],
        description=db_record.get('description'),
        organization_system=org_systems,
        phase_quality=phase_quality,
        collect=db_record['collect'],
        retrieve=db_record['retrieve'],
        consume=db_record['consume'],
        extract=db_record['extract'],
        refine=db_record['refine']
    )
```

- **Input**: `db_record` is a row from the
  [Tools](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:110:8-126:31)
  table (e.g. a dict-like object from fastlite).
- **Rebuild `phase_quality`**:
  - DB stores each quality as a string
    (`'na' | 'bad' | 'ok' | 'great'`).
  - [PhaseQualityData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:65:0-70:49)
    is reconstructed by wrapping each DB value with the
    [PhaseQuality](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:50:0-55:19)
    enum.
- **Rebuild `organization_system`**:
  - DB stores it as a JSON string representing a list of enum values,
    e.g. `["tags","folders"]`.
  - `json.loads` turns that into a Python list of strings.
  - Each string is turned into an
    [OrganizationSystem](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:57:0-62:37)
    enum instance.
- **Instantiate
  [Tool](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:72:0-133:316)**:
  - Pass all the primitive fields straight from `db_record`.
  - Pass the reconstructed `phase_quality` and `organization_system`.
- **Side-effect**:
  - [**init**](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:99:4-101:47)
    registers the instance in `Tool._instances` keyed by
    [slug](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:87:4-90:45).

**In short**:
[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)
converts DB‑friendly fields (JSON/string) back into enum-rich,
structured Pydantic objects.

------------------------------------------------------------------------

## 2. [InformationItem.from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:225:4-235:117)

``` python
@classmethod
def from_db(cls, db_record):
    toolflow = PhaseToolflowData(
        collect=cls._parse_toolflow(db_record['collect_toolflow']),
        retrieve=cls._parse_toolflow(db_record['retrieve_toolflow']),
        consume=cls._parse_toolflow(db_record['consume_toolflow']),
        extract=cls._parse_toolflow(db_record['extract_toolflow']),
        refine=cls._parse_toolflow(db_record['refine_toolflow'])
    )
    method = PhaseMethodData(
        collect=db_record['collect_method'],
        retrieve=db_record['retrieve_method'],
        consume=db_record['consume_method'],
        extract=db_record['extract_method'],
        refine=db_record['refine_method']
    )
    info_type = InformationType(db_record['info_type'])
    return cls(
        id=db_record['id'],
        name=db_record['name'],
        info_type=info_type,
        method=method,
        toolflow=toolflow
    )
```

The helper:

``` python
@staticmethod
def _parse_toolflow(v):
    if v is None: return None
    if isinstance(v, str) and v.startswith('['): return json.loads(v)
    return v
```

- **Input**: a row from
  [InformationItems](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:196:8-211:32).
- **Rebuild `toolflow`**:
  - DB stores each `*_toolflow` as either:
    - `NULL`/`None`,
    - a plain string (single tool),
    - or a JSON-encoded list (multiple tools).
  - [\_parse_toolflow](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:218:4-223:16):
    - returns `None` for `None`,
    - `json.loads` if it looks like a JSON list (starts with `'['`),
    - otherwise leaves the string as‑is.
  - Those values feed into
    [PhaseToolflowData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:144:0-159:40)
    (which itself sanitizes names via validators).
- **Rebuild `method`**:
  - Note: DB stores method values as strings (`"manual"`, `"automatic"`,
    `"na"` or `None`).
  - [PhaseMethodData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:136:0-141:47)
    fields are annotated as `Method | None`, so Pydantic will convert
    those strings to
    [Method](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:36:0-40:27)
    enums automatically.
- **Rebuild `info_type`**:
  - DB stores `info_type` as its string value (e.g. `"book"`).
  - This is wrapped into
    [InformationType](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:21:0-34:33).
- **Instantiate
  [InformationItem](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:163:0-235:117)**:
  - Pass the reconstructed `info_type`, `method`, `toolflow`, plus `id`
    and `name`.
  - [**init**](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:99:4-101:47)
    adds the instance to `InformationItem._instances`.

**In short**:
[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)
reverses the flattening that turned nested structures
([PhaseMethodData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:136:0-141:47),
[PhaseToolflowData](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:144:0-159:40),
[InformationType](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:21:0-34:33))
into many DB columns + JSON strings.

------------------------------------------------------------------------

## 3. [Improvement.from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:295:4-298:171)

``` python
@classmethod
def from_db(cls, db_record):
    phase = Phase(db_record['phase'])
    return cls(
        id=db_record['id'],
        title=db_record['title'],
        what=db_record['what'],
        why=db_record['why'],
        prio=db_record['prio'],
        tool=db_record['tool'],
        phase=phase
    )
```

- **Input**: a row from
  [Improvements](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:272:8-282:21).
- **Rebuild `phase`**:
  - DB stores `phase` as a string (e.g. `"collect"`).
  - Wrap in the
    [Phase](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:42:0-48:21)
    enum.
- **Instantiate
  [Improvement](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:238:0-298:171)**:
  - All other fields are passed through as-is.
  - [**init**](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:99:4-101:47)
    registers in `Improvement._instances`.
  - `tool` will be validated against
    [Tool.get_instances()](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:103:4-105:29)
    by the `field_validator`, so this will raise if the referenced tool
    slug is unknown.

**In short**:
[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)
here is simpler: it only converts the stored phase string to a
[Phase](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:42:0-48:21)
enum and lets Pydantic + validators do the rest.

------------------------------------------------------------------------

## Conceptual pattern across all three

- **DB schema is “flattened”**:
  - Enums → strings.
  - Lists/tuples → JSON text.
  - Nested models → multiple columns.
- **[flatten_for_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:92:4-95:19)**
  does the forward conversion to DB‑friendly fields.
- **[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)**
  does the reverse: rehydrate Enums, nested Pydantic models, and
  collections from that DB representation, returning fully-typed domain
  models ready for use in the app.

If you want, I can also trace one concrete row (e.g. a
[Tool](cci:2://file:///home/jelle/code/infoflow/infoflow/classdb.py:72:0-133:316)
with multiple `organization_system` values) through
[flatten_for_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:92:4-95:19)
→ SQLite row →
[from_db](cci:1://file:///home/jelle/code/infoflow/infoflow/classdb.py:129:4-133:316)
for a more step-by-step example.

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L77"
target="_blank" style="float:right; font-size:smaller">source</a>

### PhaseQualityData

>  PhaseQualityData (collect:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>,
>                        retrieve:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>,
>                        consume:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>,
>                        extract:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>,
>                        refine:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>)

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L86"
target="_blank" style="float:right; font-size:smaller">source</a>

### Tool

>  Tool (id:int|None=None, name:str, description:str|None=None,
>            organization_system:list[__main__.OrganizationSystem],
>            phase_quality:__main__.PhaseQualityData, collect:str|None=None,
>            retrieve:str|None=None, consume:str|None=None,
>            extract:str|None=None, refine:str|None=None)

*Pydantic dataclass for tools. This Pydantic dataclass has several
methods for converting to and from a SQLite database. This is needed
because SQLite doesn’t support all used data types. !IMPORTANT: be sure
to add or change the appropriate methods when adding or changing
fields!*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L157"
target="_blank" style="float:right; font-size:smaller">source</a>

### PhaseMethodData

>  PhaseMethodData (collect:__main__.Method|None=None,
>                       retrieve:__main__.Method|None=None,
>                       consume:__main__.Method|None=None,
>                       extract:__main__.Method|None=None,
>                       refine:__main__.Method|None=None)

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

Since `Pydantic` v2 Pydantic coerces sequences to tuples with a type of
`tuple[str, ...]` Pydantic will accept a `list[str, ...]` as a valid
input. Therefore we must include both `tuple` and `list` as a valid
instance int the staticmethod `_san`. Else the validation will return
`None` if a list is passed which is bad. It should return a `TypeError`
to inform the user to use a tuple or it should just return the values as
a tuple. The function `_san` now returns a tuple of strings if a list is
passed.

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L165"
target="_blank" style="float:right; font-size:smaller">source</a>

### PhaseToolflowData

>  PhaseToolflowData (collect:Union[str,tuple[str,...],NoneType]=None,
>                         retrieve:Union[str,tuple[str,...],NoneType]=None,
>                         consume:Union[str,tuple[str,...],NoneType]=None,
>                         extract:Union[str,tuple[str,...],NoneType]=None,
>                         refine:Union[str,tuple[str,...],NoneType]=None)

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

Example of creating an instance from
[`PhaseToolflowData`](https://Hopsakee.github.io/infoflow/classes_db.html#phasetoolflowdata)
with all possible types of input: `str`, `list[str]`, `tuple[str]` and
just skipping an entry to return `None`.

``` python
PhaseToolflowData(collect=["Reader", "Recall"], retrieve="Recall", refine=("Obsidian", "Recall"))
```

    PhaseToolflowData(collect=('reader', 'recall'), retrieve='recall', consume=None, extract=None, refine=('obsidian', 'recall'))

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L184"
target="_blank" style="float:right; font-size:smaller">source</a>

### InformationItem

>  InformationItem (id:int|None=None, name:str,
>                       info_type:__main__.InformationType,
>                       method:__main__.PhaseMethodData,
>                       toolflow:__main__.PhaseToolflowData)

*Pydantic dataclass for information items. This Pydantic dataclass has
several methods for converting to and from a SQLite database. This is
needed because SQLite doesn’t support all used data types. !IMPORTANT:
be sure to add or change the appropriate methods when adding or changing
fields!*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L270"
target="_blank" style="float:right; font-size:smaller">source</a>

### Improvement

>  Improvement (id:int|None=None, name:str, what:str, why:str, how:str,
>                   prio:int, tool:str, phase:__main__.Phase)

*Pydantic dataclass for improvements. This Pydantic dataclass has
several methods for converting to and from a SQLite database. This is
needed because SQLite doesn’t support all used data types. !IMPORTANT:
be sure to add or change the appropriate methods when adding or changing
fields!*

Test creating instances

``` python
def test_phase_quality_data():
    pqd = PhaseQualityData(collect=PhaseQuality.GREAT, retrieve=PhaseQuality.BAD, consume=PhaseQuality.OK, extract=PhaseQuality.NA, refine=PhaseQuality.GREAT)
    test_eq(pqd.collect, PhaseQuality.GREAT)
    test_eq(pqd.retrieve, PhaseQuality.BAD)

def test_tool_creation():
    tool = Tool(id=12, name="TestTool", organization_system=[OrganizationSystem.TAGS], phase_quality=PhaseQualityData(collect=PhaseQuality.GREAT, retrieve=PhaseQuality.BAD, consume=PhaseQuality.OK, extract=PhaseQuality.NA, refine=PhaseQuality.GREAT))
    test_eq(tool.name, "TestTool")
    test_eq(tool.slug, "testtool")
    test_eq(tool.phase_quality.collect, PhaseQuality.GREAT)
    return tool

def test_tool_flatten():
    tool = Tool(id=12, name="TestTool", organization_system=[OrganizationSystem.TAGS, OrganizationSystem.FOLDERS], phase_quality=PhaseQualityData(collect=PhaseQuality.GREAT, retrieve=PhaseQuality.BAD, consume=PhaseQuality.OK, extract=PhaseQuality.NA, refine=PhaseQuality.GREAT))
    flat = tool.flatten_for_db()
    test_eq(flat['collect_quality'], 'great')
    test_eq(flat['retrieve_quality'], 'bad')
    test_eq(flat['name'], 'TestTool')

def test_information_item():
    methods = PhaseMethodData(collect=Method.MANUAL, retrieve=None, consume=None, extract=None, refine=None)
    tools = PhaseToolflowData(collect="Reader", retrieve=("Recall", "Reader"), consume=None, extract=None, refine=None)
    item = InformationItem(id=16, name="Test Article", info_type=InformationType.WEB_ARTICLE, method=methods, toolflow=tools)
    test_eq(item.method.collect, Method.MANUAL)
    test_eq(item.toolflow.collect, "reader")
    test_eq(item.toolflow.retrieve, ("recall", "reader"))
    return item

def test_information_item_flatten():
    methods = PhaseMethodData(collect=Method.MANUAL, retrieve=None, consume=None, extract=None, refine=None)
    tools = PhaseToolflowData(collect=("Reader", "Recall"), retrieve="Recall", consume=None, extract=None, refine=None)
    item = InformationItem(id=16,name="Test Article", info_type=InformationType.WEB_ARTICLE, method=methods, toolflow=tools)
    flat = item.flatten_for_db()
    test_eq(flat['collect_method'], 'manual')
    test_eq(flat['retrieve_method'], None)
    test_eq(flat['collect_toolflow'], '["reader", "recall"]')
    test_eq(flat['retrieve_toolflow'], 'recall')

def test_improvement():
    imp = Improvement(id=18, name="Fix Search", what="Better search in Reader", why="Current search is bad", how="By thinking for yoursel", prio=1, tool="testtool", phase=Phase.RETRIEVE)
    test_eq(imp.name, "Fix Search")
    test_eq(imp.phase, Phase.RETRIEVE)
    test_eq(imp.flatten_for_db()['phase'], 'retrieve')
    return imp
```

``` python
OrganizationSystem("tags")
```

    <OrganizationSystem.TAGS: 'tags'>

``` python
OrganizationSystem.FOLDERS
```

    <OrganizationSystem.FOLDERS: 'folders'>

``` python
test_phase_quality_data()
test_tool_creation()
test_tool_flatten()
test_information_item()
test_information_item_flatten()
test_improvement()
```

    Improvement(id=18, name='Fix Search', what='Better search in Reader', why='Current search is bad', how='By thinking for yoursel', prio=1, tool='testtool', phase=<Phase.RETRIEVE: 'retrieve'>, slug='fix_search')

## SQLite database

#### Create and connect

Connect to the database in the `main.py`. We should also enable foreign
key constraints. These are disabled by default in Sqlite.

For testing purposes in this module we will use
`db = database(":memory:")` to create an in-memory database.

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L337"
target="_blank" style="float:right; font-size:smaller">source</a>

### create_db

>  create_db (loc:str='../data/infoflow.db')

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>loc</td>
<td>str</td>
<td>../data/infoflow.db</td>
<td>Location of the SQLite database</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>Database</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<div>

> **Tip**
>
> We can add foreign key constraints to the tables using the `transform`
> method from `sqlite_utils`.
>
> ``` python
> inf_tbl.transform(add_foreign_keys=[("<field_name>", "<table_name_to_connect>", "<field_name_in_table_to_connect>")])
> ```

</div>

But for now we won’t use foreign key constraints.

We can create the tables using the function
[`create_tables_from_pydantic`](https://Hopsakee.github.io/infoflow/classes_db.html#create_tables_from_pydantic)
but we won’t be using it. The tables will be created automatically when
we insert the first item for each table.

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L345"
target="_blank" style="float:right; font-size:smaller">source</a>

### create_tables_from_pydantic

>  create_tables_from_pydantic (db:apswutils.db.Database,
>                                   classes:List[pydantic.main.BaseModel])

Tests and usage examples

``` python
db = create_db(":memory:")
```

``` python
create_tables_from_pydantic(db, [Tool, InformationItem, Improvement])
```

``` python
db.t
```

    improvements, information_items, tools

``` python
db.t.improvements.c
```

    how, id, name, phase, prio, slug, tool, what, why

Testing of manipulating database by adding a “something” field to the
Improvement dataclass.

``` python
Improvement.get_instances()
```

    {'fix_search': Improvement(id=18, name='Fix Search', what='Better search in Reader', why='Current search is bad', how='By thinking for yoursel', prio=1, tool='testtool', phase=<Phase.RETRIEVE: 'retrieve'>, slug='fix_search')}

``` python
db.t.improvements.insert(test_improvement().flatten_for_db())
```

    {'id': 18,
     'name': 'Fix Search',
     'what': 'Better search in Reader',
     'why': 'Current search is bad',
     'how': 'By thinking for yoursel',
     'prio': 1,
     'tool': 'testtool',
     'phase': 'retrieve',
     'slug': 'fix_search'}

``` python
Improvement.get_instances()
```

    {'fix_search': Improvement(id=18, name='Fix Search', what='Better search in Reader', why='Current search is bad', how='By thinking for yoursel', prio=1, tool='testtool', phase=<Phase.RETRIEVE: 'retrieve'>, slug='fix_search')}

``` python
before_cols = [c.name for c in L(db.t.improvements.c)]
```

``` python
class Improvement(SluggedModel):
    """Pydantic dataclass for improvements. This Pydantic dataclass has several methods for converting to and from a 
    SQLite database. This is needed because SQLite doesn't support all used data types.
    !IMPORTANT: be sure to add or change the appropriate methods when adding or changing fields!"""
    id: int | None = Field(default=None, description="ID of the improvement, is automatically created when inserted in db.")
    name: str = Field(..., description="Title of the improvement")
    what: str = Field(..., description="What needs to be improved")
    why: str = Field(..., description="Why is this improvement needed")
    how: str = Field(..., description="Some ideas how to build this improvement")
    prio: int = Field(..., description="Priority of the improvement. Lowest number is highest priority")
    tool: str = Field(..., description="slug of the Tool that needs improvement")
    something: str = Field(..., description="Something")
    phase: Phase = Field(..., description="Phase that needs improvement")

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances[self.slug] = self

    @classmethod
    def get_instances(cls) -> Dict[str, "Improvement"]:
        return cls._instances

    _instances: ClassVar[Dict[str, "Improvement"]] = {}

    def flatten_for_db(self):
        return self.model_dump()

    @classmethod
    def get_db_schema(cls):
        """Returns a dataclass with SQLite-compatible field types."""
        @dataclass
        class Improvements: # Class name is used as table name automatically
            id: int
            name: str
            what: str
            why: str
            how: str
            prio: int
            tool: str
            something: str
            phase: str
            slug: str
        return Improvements

    @field_serializer('phase')
    def db_serialize(self, v):
        return v.value
    
    @field_validator('tool')
    def validate_tool_names(cls, v):
        valid_tools = Tool.get_instances().keys()
        if v not in valid_tools: raise ValueError(f"Tool '{v}' does not exist")
        return v
    
    @classmethod
    def from_db(cls, db_record):
        phase = Phase(db_record['phase'])
        return cls(id=db_record['id'], name=db_record['name'], what=db_record['what'], why=db_record['why'], prio=db_record['prio'], tool=db_record['tool'], phase=phase)
```

``` python
def test_improvement_newschema():
    imp = Improvement(id=20, name="Fix Search again", what="Better search in Reader", why="Current search is bad", how="By thinking for yoursel", prio=1, tool="testtool", something="omnious", phase=Phase.RETRIEVE)
    test_eq(imp.name, "Fix Search again")
    test_eq(imp.phase, Phase.RETRIEVE)
    test_eq(imp.flatten_for_db()['phase'], 'retrieve')
    return imp
test_improvement_newschema()
Improvement.get_instances()
```

    {'fix_search_again': Improvement(id=20, name='Fix Search again', what='Better search in Reader', why='Current search is bad', how='By thinking for yoursel', prio=1, tool='testtool', something='omnious', phase=<Phase.RETRIEVE: 'retrieve'>, slug='fix_search_again')}

``` python
create_tables_from_pydantic(db, [Improvement])
```

``` python
after_cols = [c.name for c in L(db.t.improvements.c)]
```

``` python
if before_cols == after_cols:
    raise ValueError("Improvements table conversion does not work correctly.")
```

Check if data is still in database

``` python
db.t.improvements['18'].name
```

    'Fix Search'

``` python
test_eq(db.t.improvements['18'].name, "Fix Search")
```

#### Add data to the database

Add the created instances to the SQLite tables

``` python
Tool.get_instances()
```

    {'testtool': Tool(id=12, name='TestTool', description=None, organization_system=[<OrganizationSystem.TAGS: 'tags'>, <OrganizationSystem.FOLDERS: 'folders'>], phase_quality=PhaseQualityData(collect=<PhaseQuality.GREAT: 'great'>, retrieve=<PhaseQuality.BAD: 'bad'>, consume=<PhaseQuality.OK: 'ok'>, extract=<PhaseQuality.NA: 'na'>, refine=<PhaseQuality.GREAT: 'great'>), collect=None, retrieve=None, consume=None, extract=None, refine=None, slug='testtool')}

``` python
InformationItem.get_instances()
```

    {'test_article': InformationItem(id=16, name='Test Article', info_type=<InformationType.WEB_ARTICLE: 'web_article'>, method=PhaseMethodData(collect=<Method.MANUAL: 'manual'>, retrieve=None, consume=None, extract=None, refine=None), toolflow=PhaseToolflowData(collect=('reader', 'recall'), retrieve='recall', consume=None, extract=None, refine=None), slug='test_article')}

``` python
Improvement.get_instances()
```

    {'fix_search_again': Improvement(id=20, name='Fix Search again', what='Better search in Reader', why='Current search is bad', how='By thinking for yoursel', prio=1, tool='testtool', something='omnious', phase=<Phase.RETRIEVE: 'retrieve'>, slug='fix_search_again')}

Add a single instance to the SQLite table

``` python
tst = {'name': 'NeoReader', 'collect': None, 'retrieve': None, 'consume': None, 'extract': None, 'refine': None, 'slug': 'neoreader', 'organization_system': '["folders"]', 'collect_quality': 'ok', 'retrieve_quality': 'bad', 'consume_quality': 'great', 'extract_quality': 'na', 'refine_quality': 'na'}
```

``` python
db.t.tools.insert(tst)
```

    {'id': 1,
     'name': 'NeoReader',
     'description': None,
     'collect': None,
     'retrieve': None,
     'consume': None,
     'extract': None,
     'refine': None,
     'slug': 'neoreader',
     'organization_system': '["folders"]',
     'collect_quality': 'ok',
     'retrieve_quality': 'bad',
     'consume_quality': 'great',
     'extract_quality': 'na',
     'refine_quality': 'na'}

``` python
tst2 = {'id': 1, 'name': 'NeoReader', 'collect': "hiers staat nu wat", 'retrieve': None, 'consume': None, 'extract': None, 'refine': None, 'slug': 'neoreader', 'organization_system': '["folders"]', 'collect_quality': 'ok', 'retrieve_quality': 'bad', 'consume_quality': 'great', 'extract_quality': 'na', 'refine_quality': 'na'}
```

``` python
db.t.tools.update(tst2)
```

    {'id': 1,
     'name': 'NeoReader',
     'description': None,
     'collect': 'hiers staat nu wat',
     'retrieve': None,
     'consume': None,
     'extract': None,
     'refine': None,
     'slug': 'neoreader',
     'organization_system': '["folders"]',
     'collect_quality': 'ok',
     'retrieve_quality': 'bad',
     'consume_quality': 'great',
     'extract_quality': 'na',
     'refine_quality': 'na'}

``` python
Improvement.get_instances()['fix_search_again'].flatten_for_db()
```

    {'id': 20,
     'name': 'Fix Search again',
     'what': 'Better search in Reader',
     'why': 'Current search is bad',
     'how': 'By thinking for yoursel',
     'prio': 1,
     'tool': 'testtool',
     'something': 'omnious',
     'phase': 'retrieve',
     'slug': 'fix_search_again'}

``` python
db.t.improvements.c
```

    how, id, name, phase, prio, slug, something, tool, what, why

``` python
db.t.improvements.insert(Improvement.get_instances()['fix_search_again'].flatten_for_db())
db.t.information_items.insert(InformationItem.get_instances()['test_article'].flatten_for_db())
```

    {'id': 16,
     'name': 'Test Article',
     'info_type': 'web_article',
     'slug': 'test_article',
     'collect_method': 'manual',
     'retrieve_method': None,
     'consume_method': None,
     'extract_method': None,
     'refine_method': None,
     'collect_toolflow': '["reader", "recall"]',
     'retrieve_toolflow': 'recall',
     'consume_toolflow': None,
     'extract_toolflow': None,
     'refine_toolflow': None}

``` python
[r for r in db.t.information_items.rows_where()]
```

    [{'id': 16,
      'name': 'Test Article',
      'info_type': 'web_article',
      'slug': 'test_article',
      'collect_method': 'manual',
      'retrieve_method': None,
      'consume_method': None,
      'extract_method': None,
      'refine_method': None,
      'collect_toolflow': '["reader", "recall"]',
      'retrieve_toolflow': 'recall',
      'consume_toolflow': None,
      'extract_toolflow': None,
      'refine_toolflow': None}]

Add multiple instances to the SQLite table

``` python
db.t.tools.insert_all([t.flatten_for_db() for t in Tool.get_instances().values()])
```

    <Table tools (id, name, description, collect, retrieve, consume, extract, refine, slug, organization_system, collect_quality, retrieve_quality, consume_quality, extract_quality, refine_quality)>

``` python
[t.flatten_for_db() for t in Tool.get_instances().values()]
```

    [{'id': 12,
      'name': 'TestTool',
      'description': None,
      'collect': None,
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'testtool',
      'organization_system': '["tags", "folders"]',
      'collect_quality': 'great',
      'retrieve_quality': 'bad',
      'consume_quality': 'ok',
      'extract_quality': 'na',
      'refine_quality': 'great'}]

``` python
[r for r in db.t.tools.rows]
```

    [{'id': 1,
      'name': 'NeoReader',
      'description': None,
      'collect': 'hiers staat nu wat',
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'neoreader',
      'organization_system': '["folders"]',
      'collect_quality': 'ok',
      'retrieve_quality': 'bad',
      'consume_quality': 'great',
      'extract_quality': 'na',
      'refine_quality': 'na'},
     {'id': 12,
      'name': 'TestTool',
      'description': None,
      'collect': None,
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'testtool',
      'organization_system': '["tags", "folders"]',
      'collect_quality': 'great',
      'retrieve_quality': 'bad',
      'consume_quality': 'ok',
      'extract_quality': 'na',
      'refine_quality': 'great'}]

#### Retrieve data from the database

Now retrieve the info from the database as intances from the Pydantic
Dataclass using the `MiniDataAPI` from answer.ai.

``` python
type(db.t.tools)
```

    apswutils.db.Table

``` python
db.t.tools()
```

    [{'id': 1,
      'name': 'NeoReader',
      'description': None,
      'collect': 'hiers staat nu wat',
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'neoreader',
      'organization_system': '["folders"]',
      'collect_quality': 'ok',
      'retrieve_quality': 'bad',
      'consume_quality': 'great',
      'extract_quality': 'na',
      'refine_quality': 'na'},
     {'id': 12,
      'name': 'TestTool',
      'description': None,
      'collect': None,
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'testtool',
      'organization_system': '["tags", "folders"]',
      'collect_quality': 'great',
      'retrieve_quality': 'bad',
      'consume_quality': 'ok',
      'extract_quality': 'na',
      'refine_quality': 'great'}]

``` python
tool = Tool.from_db(db.t.tools()[0])
tool
```

    Tool(id=1, name='NeoReader', description=None, organization_system=[<OrganizationSystem.FOLDERS: 'folders'>], phase_quality=PhaseQualityData(collect=<PhaseQuality.OK: 'ok'>, retrieve=<PhaseQuality.BAD: 'bad'>, consume=<PhaseQuality.GREAT: 'great'>, extract=<PhaseQuality.NA: 'na'>, refine=<PhaseQuality.NA: 'na'>), collect='hiers staat nu wat', retrieve=None, consume=None, extract=None, refine=None, slug='neoreader')

``` python
db.t.tools()
```

    [{'id': 1,
      'name': 'NeoReader',
      'description': None,
      'collect': 'hiers staat nu wat',
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'neoreader',
      'organization_system': '["folders"]',
      'collect_quality': 'ok',
      'retrieve_quality': 'bad',
      'consume_quality': 'great',
      'extract_quality': 'na',
      'refine_quality': 'na'},
     {'id': 12,
      'name': 'TestTool',
      'description': None,
      'collect': None,
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'testtool',
      'organization_system': '["tags", "folders"]',
      'collect_quality': 'great',
      'retrieve_quality': 'bad',
      'consume_quality': 'ok',
      'extract_quality': 'na',
      'refine_quality': 'great'}]

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L353"
target="_blank" style="float:right; font-size:smaller">source</a>

### dict_from_db

>  dict_from_db (db_table:apswutils.db.Table,
>                    class_table:pydantic.main.BaseModel)

*Converts a database table to a dictionary of pydantic models.*

``` python
tools_dict = dict_from_db(db.t.tools, Tool)
item_dict = dict_from_db(db.t.information_items, InformationItem)
```

``` python
getattr(db.t.improvements()[0], 'tool')
```

    'testtool'

``` python
tools_dict
```

    {'neoreader': Tool(id=1, name='NeoReader', description=None, organization_system=[<OrganizationSystem.FOLDERS: 'folders'>], phase_quality=PhaseQualityData(collect=<PhaseQuality.OK: 'ok'>, retrieve=<PhaseQuality.BAD: 'bad'>, consume=<PhaseQuality.GREAT: 'great'>, extract=<PhaseQuality.NA: 'na'>, refine=<PhaseQuality.NA: 'na'>), collect='hiers staat nu wat', retrieve=None, consume=None, extract=None, refine=None, slug='neoreader'),
     'testtool': Tool(id=12, name='TestTool', description=None, organization_system=[<OrganizationSystem.TAGS: 'tags'>, <OrganizationSystem.FOLDERS: 'folders'>], phase_quality=PhaseQualityData(collect=<PhaseQuality.GREAT: 'great'>, retrieve=<PhaseQuality.BAD: 'bad'>, consume=<PhaseQuality.OK: 'ok'>, extract=<PhaseQuality.NA: 'na'>, refine=<PhaseQuality.GREAT: 'great'>), collect=None, retrieve=None, consume=None, extract=None, refine=None, slug='testtool')}

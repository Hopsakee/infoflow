# Define Classes and create the SQLite database


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

We use `from __future__ import annotations` to support forward
references in type hints. To be precise in the `@classmethod` we create
to keep track of all instances of the class.

## Using Pydantic with MiniDataAPI and SQLite

We want to use `Pydantic` Dataclasses to enable typechecking and
validation. We also want to use the Dataclasses with the `MiniDataAPI`
to create the tables in the `SQLite` database. But `SQLite` only has
datatypes: `NULL`, `INTEGER`, `REAL`, `TEXT`, and `BLOB`. So no `list`
or any of the Dataclass(Enum) types we use.

To be able to use both `Pydanctic` and the `MiniDataAPI` we will do two
things:

1.  Define a Pydantic Dataclass with the correct datatypes and a
    Dataclass that has the same fields as the Pydantic Dataclass, but
    with datatypes that can be used with SQLite.
2.  We add `@field_serializer` methods to the Pydantic Dataclass that
    convert the fields to JSON strings when we use the method
    `.model_dump()` on the instance of the Pydantic Dataclass. These
    serialised JSON strings can then be added to the SQLite database.
3.  We also use the `@field_validator` decorator to convert the JSON
    strings back to the correct datatypes when we load the data from the
    SQLite database back into the Pydantic Dataclass.

This way we can:

- create instances with the Pydantic Dataclass to have easy typechecking
  and validation.
- convert this instances to `MiniDataAPI` and `SQLite` friendly
  datatypes using `.model_dump()` on the instance, that we can then add
  to the database.
- load the data from the SQLite database back into the Pydantic
  Dataclass.

The exact implementation can be found below where the Classes are
defined.

#### Track instances of classes

We also want to keep track of the instances available for each class.
Therefore we need some higher order magic.

- a list in the class to store the instances
- a **init** method to add the instance to the list
- a classmethod to get the list of instances

We can’t just add a `_instances = []` statement to the Class, because
Pydantic will then assume it is a model field (private attribute). We
need to tell Pydantic to ignore the \_instances class variable as a
model field and treat is as a class variable. Therefore we need to
import `ClassVar` from `typing` and use it to type the \_instances
variable.

## Enum Classes

First we define the possible values of the different variables that are
available in the classes. We use the module `enum` to define
**Enumerations**. We use this to bind the possible values to a variable
name, making the code more readable and maintainable.

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L58"
target="_blank" style="float:right; font-size:smaller">source</a>

### OrganizationSystem

>  OrganizationSystem (value, names=None, module=None, qualname=None,
>                          type=None, start=1, boundary=None)

*How tools organize and structure information.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L51"
target="_blank" style="float:right; font-size:smaller">source</a>

### PhaseQuality

>  PhaseQuality (value, names=None, module=None, qualname=None, type=None,
>                    start=1, boundary=None)

*Quality rating for how well a tool performs in each phase.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L43"
target="_blank" style="float:right; font-size:smaller">source</a>

### Phase

>  Phase (value, names=None, module=None, qualname=None, type=None, start=1,
>             boundary=None)

*The five phases of the PKM workflow.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L37"
target="_blank" style="float:right; font-size:smaller">source</a>

### Method

>  Method (value, names=None, module=None, qualname=None, type=None,
>              start=1, boundary=None)

*How actions are performed - manually or automatically.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L22"
target="_blank" style="float:right; font-size:smaller">source</a>

### InformationType

>  InformationType (value, names=None, module=None, qualname=None,
>                       type=None, start=1, boundary=None)

*Information content types that flow through the PKM workflow.*

``` python
Phase("refine")
```

    <Phase.REFINE: 'refine'>

## PKM Workflow Classes

Next we create a dataclass for each item we need to be present in the
PKM workflow.

**Pydantic Dataclasses**

Used for typechecking.

When creating a new instance for an
[`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)
the `toolflow` must be given as a list of
[`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)
objects. The typechecking makes sure that any
[`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)
object mentioned in the `toolfow` list, does exist as an actual
[`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)
instance. So make sure to first create all the
[`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)
instances that are needed for an
[`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem),
before creating the
[`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)
instance.

<div>

> **Tip**
>
> I had some serious trouble getting the Pydantic dataclass validations
> to work. One of the issues is described above and is about SQLite not
> supporting all datatypes. A second major issue is that the Pydantic
> Dataclasses reference each other. The
> [`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)
> references the
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool) in
> the `toolflow` field. I would also be convenient to store all the
> [`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)s
> that can be used with a certain
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool),
> but in that case we would create a circular reference between
> [`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)
> and
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool).
>
> We decided to remove the `information_items` list from
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool).
> When we need to get all the
> [`InformationItem`](https://Hopsakee.github.io/infoflow/classes_db.html#informationitem)s
> that are supported by a
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool) we
> can write a Python function or do a SQL-query on the SQLite database.
>
> But then we are left with the fact that we want a list of
> [`Tool`](https://Hopsakee.github.io/infoflow/classes_db.html#tool)s
> that exist. These are the options considered:
>
> - `toolflow: list[Tool]`
> - `toolflow: list[Tool.name]`
> - `toolflow: list[str]`
>
> The last option is used in combination with validation to ensure each
> string is a valid Tool.name.
>
> Here’s why this is the best approach:
>
> - Clean serialization (no complex object embedding)
> - Human-readable in the database
> - Type safety through validation
> - Easy to query
>
> The same goes for the
> [`Improvement`](https://Hopsakee.github.io/infoflow/classes_db.html#improvement)
> class and the field `tool`.

</div>

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L73"
target="_blank" style="float:right; font-size:smaller">source</a>

### Tool

>  Tool (id:int|None=None, name:str, description:str|None=None,
>            organization_system:list[__main__.OrganizationSystem],
>            phase_quality:__main__.PhaseQualityData, collect:str|None=None,
>            retrieve:str|None=None, consume:str|None=None,
>            extract:str|None=None, refine:str|None=None)

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L66"
target="_blank" style="float:right; font-size:smaller">source</a>

### PhaseQualityData

>  PhaseQualityData (collect:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>,
>                        retrieve:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>,
>                        consume:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>,
>                        extract:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>,
>                        refine:__main__.PhaseQuality=<PhaseQuality.NA: 'na'>)

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L134"
target="_blank" style="float:right; font-size:smaller">source</a>

### PhaseMethodData

>  PhaseMethodData (collect:__main__.Method|None=None,
>                       retrieve:__main__.Method|None=None,
>                       consume:__main__.Method|None=None,
>                       extract:__main__.Method|None=None,
>                       refine:__main__.Method|None=None)

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

Since `Pydantic` v2 Pydantic coerces sequences to tuples with a type of
`tuple[str, ...]` Pydantic will accept a `list[str, ...]` as a valid
input. Therefore we must include both `tuple` and `list` as a valid
instance int the staticmethod `_san`. Else the validation will return
`None` if a list is passed which is bad. It should return a `TypeError`
to inform the user to use a tuple or it should just return the values as
a tuple. The function `_san` now returns a tuple of strings if a list is
passed.

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L142"
target="_blank" style="float:right; font-size:smaller">source</a>

### PhaseToolflowData

>  PhaseToolflowData (collect:Union[str,tuple[str,...],NoneType]=None,
>                         retrieve:Union[str,tuple[str,...],NoneType]=None,
>                         consume:Union[str,tuple[str,...],NoneType]=None,
>                         extract:Union[str,tuple[str,...],NoneType]=None,
>                         refine:Union[str,tuple[str,...],NoneType]=None)

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

Example of creating an instance from
[`PhaseToolflowData`](https://Hopsakee.github.io/infoflow/classes_db.html#phasetoolflowdata)
with all possible types of input: `str`, `list[str]`, `tuple[str]` and
just skipping an entry to return `None`.

``` python
PhaseToolflowData(collect=["Reader", "Recall"], retrieve="Recall", refine=("Obsidian", "Recall"))
```

    PhaseToolflowData(collect=('reader', 'recall'), retrieve='recall', consume=None, extract=None, refine=('obsidian', 'recall'))

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L161"
target="_blank" style="float:right; font-size:smaller">source</a>

### InformationItem

>  InformationItem (id:int|None=None, name:str,
>                       info_type:__main__.InformationType,
>                       method:__main__.PhaseMethodData,
>                       toolflow:__main__.PhaseToolflowData)

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L233"
target="_blank" style="float:right; font-size:smaller">source</a>

### Improvement

>  Improvement (id:int|None=None, title:str, what:str, why:str, how:str,
>                   prio:int, tool:str, phase:__main__.Phase)

\*!!! abstract “Usage Documentation” [Models](../concepts/models.md)

A base class for creating Pydantic models.

Attributes: **class_vars**: The names of the class variables defined on
the model. **private_attributes**: Metadata about the private attributes
of the model. **signature**: The synthesized `__init__`
\[`Signature`\]\[inspect.Signature\] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*

Test creating instances

``` python
def test_phase_quality_data():
    pqd = PhaseQualityData(collect=PhaseQuality.GREAT, retrieve=PhaseQuality.BAD, consume=PhaseQuality.OK, extract=PhaseQuality.NA, refine=PhaseQuality.GREAT)
    test_eq(pqd.collect, PhaseQuality.GREAT)
    test_eq(pqd.retrieve, PhaseQuality.BAD)

def test_tool_creation():
    tool = Tool(id=12, name="TestTool", organization_system=[OrganizationSystem.TAGS], phase_quality=PhaseQualityData(collect=PhaseQuality.GREAT, retrieve=PhaseQuality.BAD, consume=PhaseQuality.OK, extract=PhaseQuality.NA, refine=PhaseQuality.GREAT))
    test_eq(tool.name, "TestTool")
    test_eq(tool.slug, "testtool")
    test_eq(tool.phase_quality.collect, PhaseQuality.GREAT)
    return tool

def test_tool_flatten():
    tool = Tool(id=12, name="TestTool", organization_system=[OrganizationSystem.TAGS, OrganizationSystem.FOLDERS], phase_quality=PhaseQualityData(collect=PhaseQuality.GREAT, retrieve=PhaseQuality.BAD, consume=PhaseQuality.OK, extract=PhaseQuality.NA, refine=PhaseQuality.GREAT))
    flat = tool.flatten_for_db()
    test_eq(flat['collect_quality'], 'great')
    test_eq(flat['retrieve_quality'], 'bad')
    test_eq(flat['name'], 'TestTool')

def test_information_item():
    methods = PhaseMethodData(collect=Method.MANUAL, retrieve=None, consume=None, extract=None, refine=None)
    tools = PhaseToolflowData(collect="Reader", retrieve=("Recall", "Reader"), consume=None, extract=None, refine=None)
    item = InformationItem(id=16, name="Test Article", info_type=InformationType.WEB_ARTICLE, method=methods, toolflow=tools)
    test_eq(item.method.collect, Method.MANUAL)
    test_eq(item.toolflow.collect, "reader")
    test_eq(item.toolflow.retrieve, ("recall", "reader"))
    return item

def test_information_item_flatten():
    methods = PhaseMethodData(collect=Method.MANUAL, retrieve=None, consume=None, extract=None, refine=None)
    tools = PhaseToolflowData(collect=("Reader", "Recall"), retrieve="Recall", consume=None, extract=None, refine=None)
    item = InformationItem(id=16,name="Test Article", info_type=InformationType.WEB_ARTICLE, method=methods, toolflow=tools)
    flat = item.flatten_for_db()
    test_eq(flat['collect_method'], 'manual')
    test_eq(flat['retrieve_method'], None)
    test_eq(flat['collect_toolflow'], '["reader", "recall"]')
    test_eq(flat['retrieve_toolflow'], 'recall')

def test_improvement():
    imp = Improvement(id=18, title="Fix Search", what="Better search in Reader", why="Current search is bad", how="By thinking for yoursel", prio=1, tool="testtool", phase=Phase.RETRIEVE)
    test_eq(imp.title, "Fix Search")
    test_eq(imp.phase, Phase.RETRIEVE)
    test_eq(imp.flatten_for_db()['phase'], 'retrieve')
    return imp
```

``` python
OrganizationSystem("tags")
```

    <OrganizationSystem.TAGS: 'tags'>

``` python
OrganizationSystem.FOLDERS
```

    <OrganizationSystem.FOLDERS: 'folders'>

``` python
test_phase_quality_data()
test_tool_creation()
test_tool_flatten()
test_information_item()
test_information_item_flatten()
test_improvement()
```

    Improvement(id=18, title='Fix Search', what='Better search in Reader', why='Current search is bad', how='By thinking for yoursel', prio=1, tool='testtool', phase=<Phase.RETRIEVE: 'retrieve'>, slug='fix_search')

## SQLite database

#### Create and connect

Connect to the database in the `main.py`. We should also enable foreign
key constraints. These are disabled by default in Sqlite.

For testing purposes in this module we will use
`db = database(":memory:")` to create an in-memory database.

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L294"
target="_blank" style="float:right; font-size:smaller">source</a>

### create_db

>  create_db (loc:str='../data/infoflow.db')

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>loc</td>
<td>str</td>
<td>../data/infoflow.db</td>
<td>Location of the SQLite database</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>Database</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<div>

> **Tip**
>
> We can add foreign key constraints to the tables using the `transform`
> method from `sqlite_utils`.
>
> ``` python
> inf_tbl.transform(add_foreign_keys=[("<field_name>", "<table_name_to_connect>", "<field_name_in_table_to_connect>")])
> ```

</div>

But for now we won’t use foreign key constraints.

We can create the tables using the function
[`create_tables_from_pydantic`](https://Hopsakee.github.io/infoflow/classes_db.html#create_tables_from_pydantic)
but we won’t be using it. The tables will be created automatically when
we insert the first item for each table.

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L302"
target="_blank" style="float:right; font-size:smaller">source</a>

### create_tables_from_pydantic

>  create_tables_from_pydantic (db:apswutils.db.Database,
>                                   classes:List[pydantic.main.BaseModel])

Tests and usage examples

``` python
db = create_db(":memory:")
```

``` python
create_tables_from_pydantic(db, [Tool, InformationItem, Improvement])
```

``` python
db.t
```

    improvements, information_items, tools

#### Add data to the database

Add the created instances to the SQLite tables

``` python
Tool.get_instances()
```

    {'testtool': Tool(id=12, name='TestTool', organization_system=[<OrganizationSystem.TAGS: 'tags'>, <OrganizationSystem.FOLDERS: 'folders'>], phase_quality=PhaseQualityData(collect=<PhaseQuality.GREAT: 'great'>, retrieve=<PhaseQuality.BAD: 'bad'>, consume=<PhaseQuality.OK: 'ok'>, extract=<PhaseQuality.NA: 'na'>, refine=<PhaseQuality.GREAT: 'great'>), collect=None, retrieve=None, consume=None, extract=None, refine=None, slug='testtool')}

``` python
InformationItem.get_instances()
```

    {'test_article': InformationItem(id=16, name='Test Article', info_type=<InformationType.WEB_ARTICLE: 'web_article'>, method=PhaseMethodData(collect=<Method.MANUAL: 'manual'>, retrieve=None, consume=None, extract=None, refine=None), toolflow=PhaseToolflowData(collect=('reader', 'recall'), retrieve='recall', consume=None, extract=None, refine=None), slug='test_article')}

Add a single instance to the SQLite table

``` python
tst = {'name': 'NeoReader', 'collect': None, 'retrieve': None, 'consume': None, 'extract': None, 'refine': None, 'slug': 'neoreader', 'organization_system': '["folders"]', 'collect_quality': 'ok', 'retrieve_quality': 'bad', 'consume_quality': 'great', 'extract_quality': 'na', 'refine_quality': 'na'}
```

``` python
db.t.tools.insert(tst)
```

    {'id': 1,
     'name': 'NeoReader',
     'collect': None,
     'retrieve': None,
     'consume': None,
     'extract': None,
     'refine': None,
     'slug': 'neoreader',
     'organization_system': '["folders"]',
     'collect_quality': 'ok',
     'retrieve_quality': 'bad',
     'consume_quality': 'great',
     'extract_quality': 'na',
     'refine_quality': 'na'}

``` python
tst2 = {'id': 1, 'name': 'NeoReader', 'collect': "hiers staat nu wat", 'retrieve': None, 'consume': None, 'extract': None, 'refine': None, 'slug': 'neoreader', 'organization_system': '["folders"]', 'collect_quality': 'ok', 'retrieve_quality': 'bad', 'consume_quality': 'great', 'extract_quality': 'na', 'refine_quality': 'na'}
```

``` python
db.t.tools.update(tst2)
```

    {'id': 1,
     'name': 'NeoReader',
     'collect': 'hiers staat nu wat',
     'retrieve': None,
     'consume': None,
     'extract': None,
     'refine': None,
     'slug': 'neoreader',
     'organization_system': '["folders"]',
     'collect_quality': 'ok',
     'retrieve_quality': 'bad',
     'consume_quality': 'great',
     'extract_quality': 'na',
     'refine_quality': 'na'}

``` python
db.t.improvements.insert(Improvement.get_instances()['fix_search'].flatten_for_db())
db.t.information_items.insert(InformationItem.get_instances()['test_article'].flatten_for_db())
```

    {'id': 16,
     'name': 'Test Article',
     'info_type': 'web_article',
     'slug': 'test_article',
     'collect_method': 'manual',
     'retrieve_method': None,
     'consume_method': None,
     'extract_method': None,
     'refine_method': None,
     'collect_toolflow': '["reader", "recall"]',
     'retrieve_toolflow': 'recall',
     'consume_toolflow': None,
     'extract_toolflow': None,
     'refine_toolflow': None}

``` python
[r for r in db.t.information_items.rows_where()]
```

    [{'id': 16,
      'name': 'Test Article',
      'info_type': 'web_article',
      'slug': 'test_article',
      'collect_method': 'manual',
      'retrieve_method': None,
      'consume_method': None,
      'extract_method': None,
      'refine_method': None,
      'collect_toolflow': '["reader", "recall"]',
      'retrieve_toolflow': 'recall',
      'consume_toolflow': None,
      'extract_toolflow': None,
      'refine_toolflow': None}]

Add multiple instances to the SQLite table

``` python
db.t.tools.insert_all([t.flatten_for_db() for t in Tool.get_instances().values()])
```

    <Table tools (id, name, collect, retrieve, consume, extract, refine, slug, organization_system, collect_quality, retrieve_quality, consume_quality, extract_quality, refine_quality)>

``` python
[t.flatten_for_db() for t in Tool.get_instances().values()]
```

    [{'id': 12,
      'name': 'TestTool',
      'collect': None,
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'testtool',
      'organization_system': '["tags", "folders"]',
      'collect_quality': 'great',
      'retrieve_quality': 'bad',
      'consume_quality': 'ok',
      'extract_quality': 'na',
      'refine_quality': 'great'}]

``` python
[r for r in db.t.tools.rows]
```

    [{'id': 1,
      'name': 'NeoReader',
      'collect': 'hiers staat nu wat',
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'neoreader',
      'organization_system': '["folders"]',
      'collect_quality': 'ok',
      'retrieve_quality': 'bad',
      'consume_quality': 'great',
      'extract_quality': 'na',
      'refine_quality': 'na'},
     {'id': 12,
      'name': 'TestTool',
      'collect': None,
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'testtool',
      'organization_system': '["tags", "folders"]',
      'collect_quality': 'great',
      'retrieve_quality': 'bad',
      'consume_quality': 'ok',
      'extract_quality': 'na',
      'refine_quality': 'great'}]

#### Retrieve data from the database

Now retrieve the info from the database as intances from the Pydantic
Dataclass using the `MiniDataAPI` from answer.ai.

``` python
type(db.t.tools)
```

    apswutils.db.Table

``` python
db.t.tools()
```

    [{'id': 1,
      'name': 'NeoReader',
      'collect': 'hiers staat nu wat',
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'neoreader',
      'organization_system': '["folders"]',
      'collect_quality': 'ok',
      'retrieve_quality': 'bad',
      'consume_quality': 'great',
      'extract_quality': 'na',
      'refine_quality': 'na'},
     {'id': 12,
      'name': 'TestTool',
      'collect': None,
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'testtool',
      'organization_system': '["tags", "folders"]',
      'collect_quality': 'great',
      'retrieve_quality': 'bad',
      'consume_quality': 'ok',
      'extract_quality': 'na',
      'refine_quality': 'great'}]

``` python
tool = Tool.from_db(db.t.tools()[0])
tool
```

    Tool(id=1, name='NeoReader', organization_system=[<OrganizationSystem.FOLDERS: 'folders'>], phase_quality=PhaseQualityData(collect=<PhaseQuality.OK: 'ok'>, retrieve=<PhaseQuality.BAD: 'bad'>, consume=<PhaseQuality.GREAT: 'great'>, extract=<PhaseQuality.NA: 'na'>, refine=<PhaseQuality.NA: 'na'>), collect='hiers staat nu wat', retrieve=None, consume=None, extract=None, refine=None, slug='neoreader')

``` python
db.t.tools()
```

    [{'id': 1,
      'name': 'NeoReader',
      'collect': 'hiers staat nu wat',
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'neoreader',
      'organization_system': '["folders"]',
      'collect_quality': 'ok',
      'retrieve_quality': 'bad',
      'consume_quality': 'great',
      'extract_quality': 'na',
      'refine_quality': 'na'},
     {'id': 12,
      'name': 'TestTool',
      'collect': None,
      'retrieve': None,
      'consume': None,
      'extract': None,
      'refine': None,
      'slug': 'testtool',
      'organization_system': '["tags", "folders"]',
      'collect_quality': 'great',
      'retrieve_quality': 'bad',
      'consume_quality': 'ok',
      'extract_quality': 'na',
      'refine_quality': 'great'}]

------------------------------------------------------------------------

<a
href="https://github.com/Hopsakee/infoflow/blob/main/infoflow/classdb.py#L310"
target="_blank" style="float:right; font-size:smaller">source</a>

### dict_from_db

>  dict_from_db (db_table:apswutils.db.Table,
>                    class_table:pydantic.main.BaseModel)

*Converts a database table to a dictionary of pydantic models.*

``` python
tools_dict = dict_from_db(db.t.tools, Tool)
item_dict = dict_from_db(db.t.information_items, InformationItem)
```

``` python
tools_dict
```

    {'neoreader': Tool(id=1, name='NeoReader', organization_system=[<OrganizationSystem.FOLDERS: 'folders'>], phase_quality=PhaseQualityData(collect=<PhaseQuality.OK: 'ok'>, retrieve=<PhaseQuality.BAD: 'bad'>, consume=<PhaseQuality.GREAT: 'great'>, extract=<PhaseQuality.NA: 'na'>, refine=<PhaseQuality.NA: 'na'>), collect='hiers staat nu wat', retrieve=None, consume=None, extract=None, refine=None, slug='neoreader'),
     'testtool': Tool(id=12, name='TestTool', organization_system=[<OrganizationSystem.TAGS: 'tags'>, <OrganizationSystem.FOLDERS: 'folders'>], phase_quality=PhaseQualityData(collect=<PhaseQuality.GREAT: 'great'>, retrieve=<PhaseQuality.BAD: 'bad'>, consume=<PhaseQuality.OK: 'ok'>, extract=<PhaseQuality.NA: 'na'>, refine=<PhaseQuality.GREAT: 'great'>), collect=None, retrieve=None, consume=None, extract=None, refine=None, slug='testtool')}

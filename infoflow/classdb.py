"""This module defines the classes we use to represent the PKM workflow."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_classes_db.ipynb.

# %% ../nbs/00_classes_db.ipynb 3
from __future__ import annotations
import json
from enum import Enum
from typing import Union, ClassVar
from dataclasses import dataclass
from pydantic import BaseModel, field_serializer, field_validator, Field, computed_field
from fastlite import *
from fastcore.test import *
from hopsa import ossys

# %% auto 0
__all__ = ['InformationType', 'Method', 'Phase', 'PhaseQuality', 'OrganizationSystem', 'PhaseQualityData', 'Tool',
           'PhaseMethodData', 'PhaseToolflowData', 'InformationItem', 'Improvement', 'create_db',
           'create_tables_from_pydantic', 'dict_from_db']

# %% ../nbs/00_classes_db.ipynb 9
class InformationType(Enum):
    """Information content types that flow through the PKM workflow."""
    BOOK = "book"
    RESEARCH_PAPER = "research_paper"
    DOCUMENT = "document"
    ANNOTATION = "annotations&highlights"
    NOTE = "note"
    EMAIL = "email"
    DISCORD_MESSAGE = "discord_message"
    WEB_ARTICLE = "web_article"
    YOUTUBE_VIDEO = "youtube_video"
    PODCAST = "podcast"
    PRODUCT_IDEA = "product_idea"
    PROJECT_IDEA = "project_idea"

class Method(Enum):
    """How actions are performed - manually or automatically."""
    NA = "na"
    MANUAL = "manual"
    AUTOMATIC = "automatic"

class Phase(Enum):
    """The five phases of the PKM workflow."""
    COLLECT = "collect"
    RETRIEVE = "retrieve"
    CONSUME = "consume"
    EXTRACT = "extract"
    REFINE = "refine"

class PhaseQuality(Enum):
    """Quality rating for how well a tool performs in each phase."""
    NA = "na"
    BAD = "bad"
    OK = "ok"
    GREAT = "great"

class OrganizationSystem(Enum):
    """How tools organize and structure information."""
    TAGS = "tags"
    FOLDERS = "folders"
    LINKS = "links"
    JOHNNY_DECIMAL = "johnny_decimal"

# %% ../nbs/00_classes_db.ipynb 15
class PhaseQualityData(BaseModel):
    collect: PhaseQuality = Field(PhaseQuality.NA)
    retrieve: PhaseQuality = Field(PhaseQuality.NA)
    consume: PhaseQuality = Field(PhaseQuality.NA)
    extract: PhaseQuality = Field(PhaseQuality.NA)
    refine: PhaseQuality = Field(PhaseQuality.NA)

class Tool(BaseModel):
    id: int | None = Field(default=None, description="ID of the tool. This is automatically created when item is added to database.")
    name: str = Field(..., description="Name of the tool")
    organization_system: list[OrganizationSystem] = Field(..., description="Organization systems supported by the tool")
    phase_quality: PhaseQualityData = Field(..., description="Quality of the tool for each phase")
    collect: str | None = Field(default=None, description="Description how to use tool in collect phase")
    retrieve: str | None = Field(default=None, description="Description how to use tool in retrieve phase")
    consume: str | None = Field(default=None, description="Description how to use tool in consume phase")
    extract: str | None = Field(default=None, description="Description how to use tool in extract phase")
    refine: str | None = Field(default=None, description="Description how to use tool in refine phase")

    @computed_field
    @property
    def slug(self) -> str:
        return ossys.sanitize_name(self.name)

    def flatten_for_db(self):
        base = self.model_dump(exclude={'phase_quality', 'organization_system'})
        base.update({'organization_system': json.dumps([org.value for org in self.organization_system]), 'collect_quality': self.phase_quality.collect.value, 'retrieve_quality': self.phase_quality.retrieve.value, 'consume_quality': self.phase_quality.consume.value, 'extract_quality': self.phase_quality.extract.value, 'refine_quality': self.phase_quality.refine.value})
        return base

    _instances: ClassVar[Dict[str, Tool]] = {}

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances[self.slug] = self

    @classmethod
    def get_instances(cls) -> Dict[str, Tool]:
        return cls._instances

    @classmethod
    def get_db_schema(cls):
        """Returns a dataclass with SQLite-compatible field types."""
        @dataclass
        class Tools: # Class name is used as table name automatically
            id: int
            name: str
            collect: str
            retrieve: str
            consume: str
            extract: str
            refine: str
            slug: str
            organization_system: str
            collect_quality: str
            retrieve_quality: str
            consume_quality: str
            extract_quality: str
            refine_quality: str
        return Tools
    
    @classmethod
    def from_db(cls, db_record):
        phase_quality = PhaseQualityData(collect=PhaseQuality(db_record['collect_quality']), retrieve=PhaseQuality(db_record['retrieve_quality']), consume=PhaseQuality(db_record['consume_quality']), extract=PhaseQuality(db_record['extract_quality']), refine=PhaseQuality(db_record['refine_quality']))
        org_systems = [OrganizationSystem(s) for s in json.loads(db_record['organization_system'])]
        return cls(id=db_record['id'], name=db_record['name'], organization_system=org_systems, phase_quality=phase_quality, collect=db_record['collect'], retrieve=db_record['retrieve'], consume=db_record['consume'], extract=db_record['extract'], refine=db_record['refine'])

# %% ../nbs/00_classes_db.ipynb 16
class PhaseMethodData(BaseModel):
    collect: Method | None = Field(default=None)
    retrieve: Method | None = Field(default=None)
    consume: Method | None = Field(default=None)
    extract: Method | None = Field(default=None)
    refine: Method | None = Field(default=None)

# %% ../nbs/00_classes_db.ipynb 18
class PhaseToolflowData(BaseModel):
    collect: Union[str, tuple[str, ...], None] = Field(default=None)
    retrieve: Union[str, tuple[str, ...], None] = Field(default=None)
    consume: Union[str, tuple[str, ...], None] = Field(default=None)
    extract: Union[str, tuple[str, ...], None] = Field(default=None)
    refine: Union[str, tuple[str, ...], None] = Field(default=None)

    @staticmethod
    def _san(v):
        if v is None: return None
        if isinstance(v, str): return ossys.sanitize_name(v)
        if isinstance(v, (list, tuple)):
            return tuple([ossys.sanitize_name(i) for i in v])
    
    @field_validator('collect', 'retrieve', 'consume', 'extract', 'refine', mode='before')
    def _val(cls, v): return cls._san(v)


# %% ../nbs/00_classes_db.ipynb 21
class InformationItem(BaseModel):
    id: int | None = Field(default=None, description="ID of the information item. Automatically created when added to the database.")
    name: str = Field(..., description="Name of the information item")
    info_type: InformationType = Field(..., description="Type of information item, e.g. book, article, video, etc.")
    method: PhaseMethodData = Field(..., description="Methods used at each phase")
    toolflow: PhaseToolflowData = Field(..., description="Tools used for this item at each phase")

    @computed_field
    @property
    def slug(self) -> str:
        return ossys.sanitize_name(self.name)

    def flatten_for_db(self):
        base = self.model_dump(exclude={'method', 'toolflow'})
        base.update({'collect_method': self.method.collect.value if self.method.collect else None, 'retrieve_method': self.method.retrieve.value if self.method.retrieve else None, 'consume_method': self.method.consume.value if self.method.consume else None, 'extract_method': self.method.extract.value if self.method.extract else None, 'refine_method': self.method.refine.value if self.method.refine else None, 'collect_toolflow': json.dumps(self.toolflow.collect) if isinstance(self.toolflow.collect, (list, tuple)) else self.toolflow.collect, 'retrieve_toolflow': json.dumps(self.toolflow.retrieve) if isinstance(self.toolflow.retrieve, (list, tuple)) else self.toolflow.retrieve, 'consume_toolflow': json.dumps(self.toolflow.consume) if isinstance(self.toolflow.consume, (list, tuple)) else self.toolflow.consume, 'extract_toolflow': json.dumps(self.toolflow.extract) if isinstance(self.toolflow.extract, (list, tuple)) else self.toolflow.extract, 'refine_toolflow': json.dumps(self.toolflow.refine) if isinstance(self.toolflow.refine, (list, tuple)) else self.toolflow.refine})
        return base

    _instances: ClassVar[Dict[str, InformationItem]] = {}

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances[self.slug] = self
    
    @classmethod
    def get_instances(cls) -> Dict[str, InformationItem]:
        return cls._instances
    
    @classmethod
    def get_db_schema(cls):
        """Returns a dataclass with SQLite-compatible field types."""
        @dataclass
        class InformationItems: # Class name is used as table name automatically
            id: int
            name: str
            info_type: str
            slug: str
            collect_method: str
            retrieve_method: str
            consume_method: str
            extract_method: str
            refine_method: str
            collect_toolflow: str
            retrieve_toolflow: str
            consume_toolflow: str
            extract_toolflow: str
            refine_toolflow: str
        return InformationItems

    @field_serializer('info_type')
    def db_serialize(self, v):
        return v.value

    @staticmethod
    def _parse_toolflow(v):
        """function to parse toolflow. Need to handle none, string and list"""
        if v is None: return None
        if isinstance(v, str) and v.startswith('['): return json.loads(v)
        return v
        
    @classmethod
    def from_db(cls, db_record):
        # We need `json.loads` here because the toolflows are stored as JSON strings in the database to allow for lists
        toolflow = PhaseToolflowData(collect=cls._parse_toolflow(db_record['collect_toolflow']),
                                    retrieve=cls._parse_toolflow(db_record['retrieve_toolflow']),
                                    consume=cls._parse_toolflow(db_record['consume_toolflow']),
                                    extract=cls._parse_toolflow(db_record['extract_toolflow']),
                                    refine=cls._parse_toolflow(db_record['refine_toolflow']))
        method = PhaseMethodData(collect=db_record['collect_method'], retrieve=db_record['retrieve_method'], consume=db_record['consume_method'], extract=db_record['extract_method'], refine=db_record['refine_method'])
        info_type = InformationType(db_record['info_type'])
        return cls(id=db_record['id'], name=db_record['name'], info_type=info_type, method=method, toolflow=toolflow)

# %% ../nbs/00_classes_db.ipynb 22
class Improvement(BaseModel):
    id: int | None = Field(default=None, description="ID of the improvement, is automatically created when inserted in db.")
    title: str = Field(..., description="Title of the improvement")
    what: str = Field(..., description="What needs to be improved")
    why: str = Field(..., description="Why is this improvement needed")
    how: str = Field(..., description="Some ideas how to build this improvement")
    prio: int = Field(..., description="Priority of the improvement. Lowest number is highest priority")
    tool: str = Field(..., description="slug of the Tool that needs improvement")
    phase: Phase = Field(..., description="Phase that needs improvement")

    @computed_field
    @property
    def slug(self) -> str:
        return ossys.sanitize_name(self.title)

    def flatten_for_db(self):
        return self.model_dump()

    _instances: ClassVar[Dict[str, Improvement]] = {}

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances[self.slug] = self
    
    @classmethod
    def get_instances(cls) -> Dict[str, Improvement]:
        return cls._instances
    
    @classmethod
    def get_db_schema(cls):
        """Returns a dataclass with SQLite-compatible field types."""
        @dataclass
        class Improvements: # Class name is used as table name automatically
            id: int
            title: str
            what: str
            why: str
            how: str
            prio: int
            tool: str
            phase: str
            slug: str
        return Improvements

    @field_serializer('phase')
    def db_serialize(self, v):
        return v.value
    
    @field_validator('tool')
    def validate_tool_names(cls, v):
        valid_tools = Tool.get_instances().keys()
        if v not in valid_tools: raise ValueError(f"Tool '{v}' does not exist")
        return v
    
    @classmethod
    def from_db(cls, db_record):
        phase = Phase(db_record['phase'])
        return cls(id=db_record['id'], title=db_record['title'], what=db_record['what'], why=db_record['why'], prio=db_record['prio'], tool=db_record['tool'], phase=phase)


# %% ../nbs/00_classes_db.ipynb 31
def create_db(
    loc: str = "../data/infoflow.db" # Location of the SQLite database
) -> Database:
    db = database(loc)
    db.execute("PRAGMA foreign_keys = ON;")
    return db

# %% ../nbs/00_classes_db.ipynb 34
def create_tables_from_pydantic(
    db: Database,
    classes: List[BaseModel]) -> Tuple[Table, Table, Table]:

    for c in classes:
        db.create(c.get_db_schema())

# %% ../nbs/00_classes_db.ipynb 60
def dict_from_db(
        db_table: Table,
        class_table: BaseModel
    ) -> dict[str, BaseModel]:
    """Converts a database table to a dictionary of pydantic models."""
    d = {}
    for t in db_table():
        d[t["slug"]] = class_table.from_db(t)
    return d

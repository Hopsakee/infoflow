"""This module defines the classes we use to represent the PKM workflow."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_classes_db.ipynb.

# %% ../nbs/00_classes_db.ipynb 3
from __future__ import annotations
import json
from enum import Enum
from typing import Union, ClassVar
from dataclasses import dataclass
from pydantic import BaseModel, field_serializer, field_validator, Field, computed_field
from fastlite import *
from fastcore.test import *
from hopsa import ossys

# %% auto 0
__all__ = ['InformationType', 'Method', 'Phase', 'PhaseQuality', 'OrganizationSystem', 'PhaseQualityData', 'Tool',
           'PhaseMethodData', 'PhaseToolflowData', 'InformationItem', 'Improvement', 'create_db',
           'create_tables_from_pydantic']

# %% ../nbs/00_classes_db.ipynb 9
class InformationType(Enum):
    """Information content types that flow through the PKM workflow."""
    BOOK = "book"
    RESEARCH_PAPER = "research_paper"
    DOCUMENT = "document"
    ANNOTATION = "annotations&highlights"
    NOTE = "note"
    EMAIL = "email"
    DISCORD_MESSAGE = "discord_message"
    WEB_ARTICLE = "web_article"
    YOUTUBE_VIDEO = "youtube_video"
    PODCAST = "podcast"
    PRODUCT_IDEA = "product_idea"
    PROJECT_IDEA = "project_idea"

class Method(Enum):
    """How actions are performed - manually or automatically."""
    MANUAL = "manual"
    AUTOMATIC = "automatic"

class Phase(Enum):
    """The five phases of the PKM workflow."""
    COLLECT = "collect"
    RETRIEVE = "retrieve"
    CONSUME = "consume"
    EXTRACT = "extract"
    REFINE = "refine"

class PhaseQuality(Enum):
    """Quality rating for how well a tool performs in each phase."""
    NA = "na"
    BAD = "bad"
    OK = "ok"
    GREAT = "great"

class OrganizationSystem(Enum):
    """How tools organize and structure information."""
    TAGS = "tags"
    FOLDERS = "folders"
    LINKS = "links"
    JOHNNY_DECIMAL = "johnny_decimal"

# %% ../nbs/00_classes_db.ipynb 15
class PhaseQualityData(BaseModel):
    collect: PhaseQuality = Field(PhaseQuality.NA)
    retrieve: PhaseQuality = Field(PhaseQuality.NA)
    consume: PhaseQuality = Field(PhaseQuality.NA)
    extract: PhaseQuality = Field(PhaseQuality.NA)
    refine: PhaseQuality = Field(PhaseQuality.NA)

class Tool(BaseModel):
    name: str = Field(..., description="Name of the tool")
    organization_system: list[OrganizationSystem] = Field(..., description="Organization systems supported by the tool")
    phase_quality: PhaseQualityData = Field(..., description="Quality of the tool for each phase")
    collect: str | None = Field(default=None, description="Description how to use tool in collect phase")
    retrieve: str | None = Field(default=None, description="Description how to use tool in retrieve phase")
    consume: str | None = Field(default=None, description="Description how to use tool in consume phase")
    extract: str | None = Field(default=None, description="Description how to use tool in extract phase")
    refine: str | None = Field(default=None, description="Description how to use tool in refine phase")

    @computed_field
    @property
    def slug(self) -> str:
        return ossys.sanitize_name(self.name)

    def flatten_for_db(self):
        base = self.model_dump(exclude={'phase_quality', 'organization_system'})
        base.update({'organization_system': json.dumps([org.value for org in self.organization_system]), 'collect_quality': self.phase_quality.collect.value, 'retrieve_quality': self.phase_quality.retrieve.value, 'consume_quality': self.phase_quality.consume.value, 'extract_quality': self.phase_quality.extract.value, 'refine_quality': self.phase_quality.refine.value})
        return base

    _instances: ClassVar[Dict[str, Tool]] = {}

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances[self.slug] = self
    
    @classmethod
    def get_instances(cls) -> Dict[str, Tool]:
        return cls._instances
    
  
    @classmethod
    def from_db(cls, db_record):
        phase_quality = PhaseQualityData(collect=PhaseQuality(db_record['collect_quality']), retrieve=PhaseQuality(db_record['retrieve_quality']), consume=PhaseQuality(db_record['consume_quality']), extract=PhaseQuality(db_record['extract_quality']), refine=PhaseQuality(db_record['refine_quality']))
        org_systems = [OrganizationSystem(s) for s in json.loads(db_record['organization_system'])]
        return cls(name=db_record['name'], organization_system=org_systems, phase_quality=phase_quality, collect=db_record['collect'], retrieve=db_record['retrieve'], consume=db_record['consume'], extract=db_record['extract'], refine=db_record['refine'])

# %% ../nbs/00_classes_db.ipynb 16
class PhaseMethodData(BaseModel):
    collect: Method | None = Field(default=None)
    retrieve: Method | None = Field(default=None)
    consume: Method | None = Field(default=None)
    extract: Method | None = Field(default=None)
    refine: Method | None = Field(default=None)

# %% ../nbs/00_classes_db.ipynb 18
class PhaseToolflowData(BaseModel):
    collect: Union[str, tuple[str, ...], None] = Field(default=None)
    retrieve: Union[str, tuple[str, ...], None] = Field(default=None)
    consume: Union[str, tuple[str, ...], None] = Field(default=None)
    extract: Union[str, tuple[str, ...], None] = Field(default=None)
    refine: Union[str, tuple[str, ...], None] = Field(default=None)

    @staticmethod
    def _san(v):
        if v is None: return None
        if isinstance(v, str): return ossys.sanitize_name(v)
        if isinstance(v, (list, tuple)):
            return tuple([ossys.sanitize_name(i) for i in v])
    
    @field_validator('collect', 'retrieve', 'consume', 'extract', 'refine', mode='before')
    def _val(cls, v): return cls._san(v)


# %% ../nbs/00_classes_db.ipynb 21
class InformationItem(BaseModel):
    name: str = Field(..., description="Name of the information item")
    info_type: InformationType = Field(..., description="Type of information item, e.g. book, article, video, etc.")
    method: PhaseMethodData = Field(..., description="Methods used at each phase")
    toolflow: PhaseToolflowData = Field(..., description="Tools used for this item at each phase")

    @computed_field
    @property
    def slug(self) -> str:
        return ossys.sanitize_name(self.name)

    def flatten_for_db(self):
        base = self.model_dump(exclude={'method', 'toolflow'})
        base.update({'collect_method': self.method.collect.value if self.method.collect else None, 'retrieve_method': self.method.retrieve.value if self.method.retrieve else None, 'consume_method': self.method.consume.value if self.method.consume else None, 'extract_method': self.method.extract.value if self.method.extract else None, 'refine_method': self.method.refine.value if self.method.refine else None, 'collect_toolflow': json.dumps(self.toolflow.collect) if isinstance(self.toolflow.collect, (list, tuple)) else self.toolflow.collect, 'retrieve_toolflow': json.dumps(self.toolflow.retrieve) if isinstance(self.toolflow.retrieve, (list, tuple)) else self.toolflow.retrieve, 'consume_toolflow': json.dumps(self.toolflow.consume) if isinstance(self.toolflow.consume, (list, tuple)) else self.toolflow.consume, 'extract_toolflow': json.dumps(self.toolflow.extract) if isinstance(self.toolflow.extract, (list, tuple)) else self.toolflow.extract, 'refine_toolflow': json.dumps(self.toolflow.refine) if isinstance(self.toolflow.refine, (list, tuple)) else self.toolflow.refine})
        return base

    _instances: ClassVar[Dict[str, InformationItem]] = {}

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances[self.slug] = self
    
    @classmethod
    def get_instances(cls) -> Dict[str, InformationItem]:
        return cls._instances
    
    @field_serializer('info_type')
    def db_serialize(self, v):
        return v.value


# %% ../nbs/00_classes_db.ipynb 22
class Improvement(BaseModel):
    title: str = Field(..., description="Title of the improvement")
    what: str = Field(..., description="What needs to be improved")
    why: str = Field(..., description="Why is this improvement needed")
    prio: int = Field(..., description="Priority of the improvement")
    tool: str = Field(..., description="Tool that needs improvement")
    phase: Phase = Field(..., description="Phase that needs improvement")

    @computed_field
    @property
    def slug(self) -> str:
        return ossys.sanitize_name(self.title)

    def flatten_for_db(self):
        return self.model_dump()

    _instances: ClassVar[Dict[str, Improvement]] = {}

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances[self.slug] = self
    
    @classmethod
    def get_instances(cls) -> Dict[str, Improvement]:
        return cls._instances
    
    @field_serializer('phase')
    def db_serialize(self, v):
        return v.value
    
    @field_validator('tool')
    def validate_tool_names(cls, v):
        valid_tools = Tool.get_instances().keys()
        if v not in valid_tools: raise ValueError(f"Tool '{v}' does not exist")
        return v

# %% ../nbs/00_classes_db.ipynb 29
def create_db(loc="static/infoflow.db"):
    db = database(loc)
    db.execute("PRAGMA foreign_keys = ON;")
    return db


# %% ../nbs/00_classes_db.ipynb 32
def create_tables_from_pydantic(db):
    sample_tool = Tool(name="Sample", organization_system=[OrganizationSystem.TAGS], phase_quality=PhaseQualityData(collect=PhaseQuality.GREAT, retrieve=PhaseQuality.BAD, consume=PhaseQuality.OK, extract=PhaseQuality.NA, refine=PhaseQuality.GREAT))
    sample_item = InformationItem(name="Sample", info_type=InformationType.WEB_ARTICLE, method=PhaseMethodData(collect=Method.MANUAL, retrieve=None, consume=None, extract=None, refine=None), toolflow=PhaseToolflowData(collect="Reader", retrieve="Recall", consume=None, extract=None, refine=None))
    sample_imp = Improvement(title="Sample", what="Test", why="Test", prio=1, tool="sample", phase=Phase.COLLECT)
    
    db["tools"].insert(sample_tool.flatten_for_db(), pk="slug")
    db["information_items"].insert(sample_item.flatten_for_db(), pk="slug") 
    db["improvements"].insert(sample_imp.flatten_for_db(), pk="slug")
    
    db["tools"].delete("sample")
    db["information_items"].delete("sample")
    db["improvements"].delete("sample")
    
    return db.t.tools, db.t.information_items, db.t.improvements

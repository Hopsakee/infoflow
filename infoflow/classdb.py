"""This module defines the classes we use to represent the PKM workflow."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_classes_db.ipynb.

# %% ../nbs/00_classes_db.ipynb 3
from __future__ import annotations

# %% auto 0
__all__ = ['InformationType', 'Method', 'Phase', 'PhaseQuality', 'OrganizationSystem', 'InformationItem', 'Tool', 'Improvement',
           'ImprovementDB', 'InformationItemDB', 'ToolDB', 'create_db']

# %% ../nbs/00_classes_db.ipynb 4
import json
from enum import Enum
from typing import List, Union, ClassVar
from dataclasses import dataclass
from pydantic import BaseModel, field_serializer, field_validator, Field
from fastlite import *
from fastcore.test import *

# %% ../nbs/00_classes_db.ipynb 8
class InformationType(Enum):
    """Information content types that flow through the PKM workflow."""
    BOOK = "book"
    RESEARCH_PAPER = "research_paper"
    DOCUMENT = "document"
    ANNOTATION = "annotations&highlights"
    NOTE = "note"
    EMAIL = "email"
    DISCORD_MESSAGE = "discord_message"
    WEB_ARTICLE = "web_article"
    YOUTUBE_VIDEO = "youtube_video"
    PODCAST = "podcast"
    PRODUCT_IDEA = "product_idea"
    PROJECT_IDEA = "project_idea"

class Method(Enum):
    """How actions are performed - manually or automatically."""
    MANUAL = "manual"
    AUTOMATIC = "automatic"

class Phase(Enum):
    """The five phases of the PKM workflow."""
    COLLECT = "collect"
    RETRIEVE = "retrieve"
    CONSUME = "consume"
    EXTRACT = "extract"
    REFINE = "refine"

class PhaseQuality(Enum):
    """Quality rating for how well a tool performs in each phase."""
    NA = "na"
    BAD = "bad"
    OK = "ok"
    GREAT = "great"

class OrganizationSystem(Enum):
    """How tools organize and structure information."""
    TAGS = "tags"
    FOLDERS = "folders"
    LINKS = "links"
    JOHNNY_DECIMAL = "johnny_decimal"

# %% ../nbs/00_classes_db.ipynb 16
class InformationItem(BaseModel):
    """Represents an information item flowing through the PKM workflow."""
    name: str = Field(..., description="Name of the information item")
    info_type: InformationType = Field(..., description="Type of information item, e.g. book, article, video, etc.")
    method: list[Union[Method, None]] = Field(..., description="Methods used at each phase in order: collect, retrieve, consume, extract, refine")
    toolflow: list[Union[str, list[str], tuple[str], None]] = Field(..., description="Tools used for this item at each phase in order: collect, retrieve, consume, extract, refine")

    _instances: ClassVar[List[InformationItem]] = []

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances.append(self)
    
    @classmethod
    def get_instances(cls) -> list[InformationItem]:
        return cls._instances.copy()
    
    @field_serializer('info_type','method', 'toolflow')
    def db_serialize(self, v):
        if isinstance(v, list):
            return json.dumps([i.value if hasattr(i, 'value') else i for i in v])
        return str(v.value) if hasattr(v, 'value') else v
    
    @field_validator('info_type','method', 'toolflow', mode='before')
    def parse_json_lists(cls, value):
        if isinstance(value, str):
            return json.loads(value)
        return value
    
    @field_validator('toolflow')
    def validate_tool_names(cls, v):
        if len(v) != 5:
            raise ValueError(f"Toolflow must have 5 tools, got {len(v)}")
        valid_tools = {tool.name for tool in Tool.get_instances()}
        for p in v: # Phase-tools
            if p is None:
                continue
            elif isinstance(p, str): # Case of single tool in phase
                if p not in valid_tools: raise ValueError(f"Tool '{p}' does not exist")
            elif isinstance(p, (list, tuple)): # Case of multiple tools in phase
                for t in p:
                    if t not in valid_tools: raise ValueError(f"Tool '{t}' does not exist")
            else:
                raise ValueError(f"Tool '{p}' is not a string or list of strings or tuple of strings")

        return v


class Tool(BaseModel):
    """Represents a PKM tool with information on the supported OrganizationSystems and for each Phase the perceived quality."""
    name: str = Field(..., description="Name of the tool")
    organization_system: list[OrganizationSystem] = Field(..., description="Organization systems supported by the tool")
    phase_quality: list[PhaseQuality] = Field(..., description="Quality of the tool for each phase in order: collect, retrieve, consume, extract, refine")

    _instances: ClassVar[List[Tool]] = []

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances.append(self)
    
    @classmethod
    def get_instances(cls) -> list[Tool]:
        return cls._instances.copy()
    
    @field_serializer('organization_system', 'phase_quality')
    def db_serialize(self, v):
        if isinstance(v, list):
            return json.dumps([i.value if hasattr(i, 'value') else i for i in v])
        return str(v.value) if hasattr(v, 'value') else v
    
    @field_validator('organization_system', 'phase_quality', mode='before')
    def parse_json_lists(cls, value):
        if isinstance(value, str):
            return json.loads(value)
        return value
    
    @field_validator('phase_quality')
    def validate_phase_quality(cls, v):
        if len(v) != 5:
            raise ValueError(f"Phase quality must have 5 phases, got {len(v)}")
        return v
    

class Improvement(BaseModel):
    """Tracks workflow improvements needed for better PKM effectiveness."""
    title: str = Field(..., description="Title of the improvement")
    what: str = Field(..., description="What needs to be improved")
    why: str = Field(..., description="Why is this improvement needed")
    prio: int = Field(..., description="Priority of the improvement")
    tool: str = Field(..., description="Tool that needs improvement")
    phase: Phase = Field(..., description="Phase that needs improvement")

    _instances: ClassVar[List[Improvement]] = []

    def __init__(self, **data):
        super().__init__(**data)
        type(self)._instances.append(self)
    
    @classmethod
    def get_instances(cls) -> list[Improvement]:
        return cls._instances.copy()
    
    @field_serializer('tool', 'phase')
    def db_serialize(self, v):
        if isinstance(v, list):
            return json.dumps([i.value if hasattr(i, 'value') else i for i in v])
        return str(v.value) if hasattr(v, 'value') else v
    
    @field_validator('phase', mode='before')
    def parse_json_lists(cls, value):
        if isinstance(value, str):
            return json.loads(value)
        return value
    
    @field_validator('tool')
    def validate_tool_names(cls, v):
        valid_tools = {tool.name for tool in Tool.get_instances()}
        if v not in valid_tools:
            raise ValueError(f"Tool '{tool_name}' does not exist")
        return v

# %% ../nbs/00_classes_db.ipynb 22
@dataclass
class ImprovementDB:
    id: int
    title: str
    what: str
    why: str
    prio: int
    tool: str
    phase: str

@dataclass
class InformationItemDB:
    id: int
    name: str
    info_type: str
    method: str
    toolflow: str

@dataclass
class ToolDB:
    id: int
    name: str
    organization_system: str
    phase_quality: str

# %% ../nbs/00_classes_db.ipynb 28
def create_db(loc="static/infoflow.db"):
    db = database(loc)
    db.execute("PRAGMA foreign_keys = ON;")
    inf_tbl = db.create(InformationItemDB)
    tool_tbl = db.create(ToolDB)
    impr_tbl = db.create(ImprovementDB)
    return db, inf_tbl, tool_tbl, impr_tbl

